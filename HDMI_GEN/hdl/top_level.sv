`default_nettype none // prevents system from inferring an undeclared logic (good practice)
 
module top_level(
  input wire clk_100mhz, //crystal reference clock
  input wire [15:0] sw, //all 16 input slide switches
  input wire [3:0] btn, //all four momentary button switches
  output logic [15:0] led, //16 green output LEDs (located right above switches)
  output logic [2:0] rgb0, //rgb led
  output logic [2:0] rgb1, //rgb led
  output logic [2:0] hdmi_tx_p, //hdmi output signals (positives) (blue, green, red)
  output logic [2:0] hdmi_tx_n, //hdmi output signals (negatives) (blue, green, red)
  output logic hdmi_clk_p, hdmi_clk_n //differential hdmi clock
  );
 
  assign led = sw; //to verify the switch values
  //shut up those rgb LEDs (active high):
  assign rgb1= 0;
  assign rgb0 = 0;
 
  //have btn[0] control system reset
  logic sys_rst;
  assign sys_rst = btn[0]; //reset is btn[0]
  logic game_rst;
  assign game_rst = btn[1]; //reset is btn[1]
 
  logic clk_pixel, clk_5x; //clock lines
  logic locked; //locked signal (we'll leave unused but still hook it up)
 
  //clock manager...creates 74.25 Hz and 5 times 74.25 MHz for pixel and TMDS
  hdmi_clk_wiz_720p mhdmicw (
      .reset(0),
      .locked(locked),
      .clk_ref(clk_100mhz),
      .clk_pixel(clk_pixel),
      .clk_tmds(clk_5x));

 
  logic [10:0] hcount; //hcount of system!
  logic [9:0] vcount; //vcount of system!
  logic hor_sync; //horizontal sync signal
  logic vert_sync; //vertical sync signal
  logic active_draw; //ative draw! 1 when in drawing region.0 in blanking/sync
  logic new_frame; //one cycle active indicator of new frame of info!
  logic [5:0] frame_count; //0 to 59 then rollover frame counter
 
  //written by you previously! (make sure you include in your hdl)
  //default instantiation so making signals for 720p
  video_sig_gen mvg(
      .pixel_clk_in(clk_pixel),
      .rst_in(sys_rst),
      .hcount_out(hcount),
      .vcount_out(vcount),
      .vs_out(vert_sync),
      .hs_out(hor_sync),
      .ad_out(active_draw),
      .nf_out(new_frame),
      .fc_out(frame_count));
 
  logic [7:0] red, green, blue; //red green and blue pixel values for output
  logic [7:0] tp_r, tp_g, tp_b; //color values as generated by test_pattern module
  logic [7:0] pg_r, pg_g, pg_b;//color values as generated by pong game(part 2)
  

  logic [7:0] divider;
  assign divider = 0;
  //comment out in checkoff 1 once you know you have your video pipeline working:
  // these three colors should be a nice pink (6.205 sidebar) color on full screen .
  assign pg_r = (frame_count % 2 == 0) ? 8'hFF : 8'h00;
  assign pg_g = (frame_count % 2 == 0) ? 8'hFF : 8'h00;
  assign pg_b = (frame_count % 2 == 0) ? 8'hFF : 8'h00;
 
  assign tp_r = ((vcount + hcount) % 2 == 0) ? 8'hFF : 8'h00;
  assign tp_g = ((vcount + hcount) % 2 == 0) ? 8'hFF : 8'h00;
  assign tp_b = ((vcount + hcount) % 2 == 0) ? 8'hFF : 8'h00;
 
  always_comb begin
    if (sw[2])begin //if switch 3 switched use shapes signal from part 2, else defaults
      red = tp_r;
      green = tp_g;
      blue = tp_b;
    end else begin
      red = pg_r;
      green = pg_g;
      blue = pg_b;
    end
  end

  logic [31:0] counter;   
  logic on;               
  logic clk_update;      

  logic [40:0] hardcoded = {1'b0, 6'b11111, 32'h32_30_32_34, 1'b1, 1'b0}; 
  logic [31:0] index = 0;


  //1 sec = d74250000
  //0.5 sec = d37125000
  always_ff @(posedge clk_pixel) begin
    if (!sw[0]) begin
        counter <= 0;
        clk_update <= 0;
        index <= 0;
    end else begin
        if (counter == 32'd3712500) begin
            counter <= 0;
            clk_update <= 1;   
            index <= index + 1;
        end else begin
            counter <= counter + 1;
            clk_update <= 0;        
        end
    end
end

always_ff @(posedge clk_pixel) begin
    if (!sw[0]) begin
        on <= 0;  // Turn off when `sw[0]` is low
    end else //if (clk_update) begin
        // on <= ~on;  // Toggle `on` every second
        on <= hardcoded[index];
    end
//end

  // logic on;
  // assign on = sw[0];

  
  logic [9:0] tmds_10b_pre_kill [0:2]; //output of each TMDS encoder!
  logic [9:0] tmds_10b [0:2]; //output of each TMDS encoder!
  logic tmds_signal [2:0]; //output of each TMDS serializer!
 
  //three tmds_encoders (blue, green, red)
  //MISSING two more tmds encoders (one for green and one for blue)
  //note green should have no control signal like red
  //the blue channel DOES carry the two sync signals:
  //  * control_in[0] = horizontal sync signal
  //  * control_in[1] = vertical sync signal
 
  tmds_encoder tmds_red(
      .clk_in(clk_pixel),
      .rst_in(sys_rst),
      .data_in(red),
      .control_in(2'b0),
      .ve_in(active_draw),
      .tmds_out(tmds_10b_pre_kill[2]));

  tmds_encoder tmds_green(
    .clk_in(clk_pixel),
    .rst_in(sys_rst),
    .data_in(green),
    .control_in(2'b0),
    .ve_in(active_draw),
    .tmds_out(tmds_10b_pre_kill[1]));
    
  tmds_encoder tmds_blue(
    .clk_in(clk_pixel),
    .rst_in(sys_rst),
    .data_in(blue),
    .control_in({vert_sync, hor_sync}),
    .ve_in(active_draw),
    .tmds_out(tmds_10b_pre_kill[0]));

  logic [9:0] kill = {10{on}};
  assign tmds_10b[0] = tmds_10b_pre_kill[0] & kill;
  assign tmds_10b[1] = tmds_10b_pre_kill[1] & kill;
  assign tmds_10b[2] = tmds_10b_pre_kill[2] & kill;
 
  //three tmds_serializers (blue, green, red):
  //MISSING: two more serializers for the green and blue tmds signals.
  tmds_serializer red_ser(
      .clk_pixel_in(clk_pixel),
      .clk_5x_in(clk_5x),
      .rst_in(sys_rst),
      .tmds_in(tmds_10b[2]),
      .tmds_out(tmds_signal[2]));

  tmds_serializer green_ser(
      .clk_pixel_in(clk_pixel),
      .clk_5x_in(clk_5x),
      .rst_in(sys_rst),
      .tmds_in(tmds_10b[1]),
      .tmds_out(tmds_signal[1]));

  logic [9:0] blue_sig;
  assign blue_sig = (!active_draw) ? tmds_10b[0] : {blue[7:6], blue};

  tmds_serializer blue_ser(
      .clk_pixel_in(clk_pixel),
      .clk_5x_in(clk_5x),
      .rst_in(sys_rst),
      .tmds_in(tmds_10b[0]),
      .tmds_out(tmds_signal[0]));
 
   

  logic inp_clock;
  assign inp_clock = clk_pixel & on;
  //output buffers generating differential signals:
  //three for the r,g,b signals and one that is at the pixel clock rate
  //the HDMI receivers use recover logic coupled with the control signals asserted
  //during blanking and sync periods to synchronize their faster bit clocks off
  //of the slower pixel clock (so they can recover a clock of about 742.5 MHz from
  //the slower 74.25 MHz clock)
  OBUFDS OBUFDS_blue (.I(tmds_signal[0]), .O(hdmi_tx_p[0]), .OB(hdmi_tx_n[0]));
  OBUFDS OBUFDS_green(.I(tmds_signal[1]), .O(hdmi_tx_p[1]), .OB(hdmi_tx_n[1]));
  OBUFDS OBUFDS_red  (.I(tmds_signal[2]), .O(hdmi_tx_p[2]), .OB(hdmi_tx_n[2]));
  OBUFDS OBUFDS_clock(.I(inp_clock), .O(hdmi_clk_p), .OB(hdmi_clk_n));
  
 
endmodule // top_level
`default_nettype wire